<link rel="stylesheet" title="Default" href="styles/default.css"><hr>
<p>title:        &#39;Configuring Marlin 1.1&#39;
description:  &#39;Complete guide to Marlin configuration options.&#39;</p>
<p>author: Sarf2k4
contrib: paulusjacobus, jbrazio, landodragon141, thinkyhead</p>
<h2 id="category-configuration-">category: [ configuration ]</h2>
<h1 id="introduction">Introduction</h1>
<p>Marlin is a huge C++ program composed of many files, but here we&#39;ll only be talking about the two files that contain all of Marlin&#39;s compile-time configuration options:</p>
<ul>
<li><code>Configuration.h</code> contains the core settings for the hardware, language and controller selection, and settings for the most common features and components.</li>
<li><code>Configuration_adv.h</code> serves up more detailed customization options, add-ons, experimental features, and other esoterica.</li>
</ul>
<p>These two files contain all of Marlin&#39;s build-time configuration options. Simply edit or replace these files before building and uploading Marlin to the board. A variety of pre-built configurations are included in the <code>example_configurations</code> folder to get you started.</p>
<p>To use configurations from an earlier version of Marlin, try dropping them into the newer Marlin and building. As part of the build process, the <code>SanityCheck.h</code> will print helpful error messages explaining what needs to be changed.</p>
<h2 id="compiler-directives">Compiler Directives</h2>
<p>Marlin is configured using C++ compiler directives. This allows Marlin to leverage the C++ preprocessor and include only the code and data needed for the enabled options. This results in the smallest possible binary. A build of Marlin can range from 50K to over 230K in size.</p>
<p>Settings can be enabled, disabled, and assigned values using C preprocessor syntax like so:</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THIS_IS_ENABLED    <span class="hljs-comment">// this switch is enabled</span></span>
<span class="hljs-comment">//#define THIS_IS_DISABLED // this switch is disabled</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OPTION_VALUE 22    <span class="hljs-comment">// this setting is "22"</span></span>
</code></pre>
<h2 id="sources-of-documentation">Sources of Documentation</h2>
<p>The most authoritative source on configuration details will always be <strong>the configuration files themselves</strong>. They provide good descriptions of each option, and are themselves the source for most of the information presented here.</p>
<p>If you&#39;ve never configured and calibrated a RepRap machine before, here are some good resources:</p>
<ul>
<li><a href="http://reprap.org/wiki/Calibration">Calibration</a></li>
<li><a href="http://youtu.be/wAL9d7FgInk">Calibrating Steps-per-unit</a></li>
<li><a href="http://calculator.josefprusa.cz">Prusa&#39;s calculators</a></li>
<li><a href="http://reprap.org/wiki/Triffid_Hunter%27s_Calibration_Guide">Triffid Hunter&#39;s Calibration Guide</a></li>
<li><a href="http://www.thingiverse.com/thing:5573">The Essential Calibration Set</a></li>
<li><a href="https://sites.google.com/site/repraplogphase/calibration-of-your-reprap">Calibration of your RepRap</a></li>
<li><a href="http://www.thingiverse.com/thing:298812">XY 20 mm Calibration Box</a></li>
<li><a href="http://reprap.org/wiki/G-code">G-Code reference</a></li>
<li><a href="https://github.com/cabbagecreek/Marlin3DprinterTool">Marlin3DprinterTool</a></li>
</ul>
<h2 id="before-you-begin">Before You Begin</h2>
<p>To get your core <code>Configuration.h</code> settings right you&#39;ll need to know the following things about your printer:</p>
<ul>
<li>Printer style, such as Cartesian, Delta, CoreXY, or SCARA</li>
<li>Driver board, such as RAMPS, RUMBA, Teensy, etc.</li>
<li>Number of extruders</li>
<li>Steps-per-mm for XYZ axes and extruders (can be tuned later)</li>
<li>Endstop positions</li>
<li>Thermistors and/or thermocouples</li>
<li>Probes and probing settings</li>
<li>LCD controller brand and model</li>
<li>Add-ons and custom components</li>
</ul>
<h1 id="-configuration-h-"><code>Configuration.h</code></h1>
<p>The core and default settings of Marlin live in the <code>Configuration.h</code> file. Most of these settings are fixed. Once you compile Marlin, that&#39;s it. To change them you need to re-compile. However, several items in <code>Configuration.h</code> only provide defaults -factory settings- that can be changed via the user interface, stored on EEPROM and reloaded or restored to initial values.</p>
<p>{% alert info %}
Settings that can be changed and saved to EEPROM are marked with <em class="fa fa-sticky-note-o" aria-hidden="true"></em>. Options marked with <em class="fa fa-desktop" aria-hidden="true"></em> can be changed from the LCD controller.
{% endalert %}</p>
<p>This section follows the order of settings as they appear. The order isn&#39;t always logical, so &quot;Search In Page&quot; may be helpful. We&#39;ve tried to keep descriptions brief and to the point. For more detailed information on various topics, please read the main articles and follow the links provided in the option descriptions.</p>
<h2 id="configuration-versioning">Configuration versioning</h2>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIGURATION_H_VERSION 010100</span>
</code></pre>
<p>Marlin now checks for a configuration version and won&#39;t compile without this setting. If you want to upgrade from an earlier version of Marlin, add this line to your old configuration file. During compilation, Marlin will throw errors explaining what needs to be changed.</p>
<h2 id="firmware-info">Firmware Info</h2>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRING_CONFIG_H_AUTHOR <span class="hljs-meta-string">"(none, default config)"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHOW_BOOTSCREEN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRING_SPLASH_LINE1 SHORT_BUILD_VERSION <span class="hljs-comment">// will be shown during bootup in line 1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRING_SPLASH_LINE2 WEBSITE_URL         <span class="hljs-comment">// will be shown during bootup in line 2</span></span>
</code></pre>
<ul>
<li><code>STRING_CONFIG_H_AUTHOR</code> is shown in the Marlin startup message, and is meant to identify the author (and optional variant) of the firmware. Use this setting as a way to uniquely identify all your custom configurations. The startup message is printed when connecting to host software, and whenever the board reboots.</li>
<li><code>SHOW_BOOTSCREEN</code> enables the boot screen for LCD controllers.</li>
<li><code>STRING_SPLASH_LINE1</code> and <code>STRING_SPLASH_LINE2</code> are shown on the boot screen.</li>
</ul>
<h2 id="hardware-info">Hardware Info</h2>
<h3 id="serial-port">Serial Port</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SERIAL_PORT 0</span>
</code></pre>
<p>The index of the on-board serial port that will be used for primary host communication. Change this if, for example, you need to connect a wireless adapter to non-default port pins. Serial port 0 will be used by the Arduino bootloader regardless of this setting.</p>
<h3 id="baud-rate">Baud Rate</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BAUDRATE 115200</span>
</code></pre>
<p>The serial communication speed of the printer should be as fast as it can manage without generating errors. In most cases 115200 gives a good balance between speed and stability. Start with 250000 and only go lower if &quot;line number&quot; and &quot;checksum&quot; errors start to appear. Note that some boards (e.g., a temperamental Sanguinololu clone based on the ATMEGA1284P) may not be able to handle a baudrate over 57600. Allowed values: 2400, 9600, 19200, 38400, 57600, 115200, 250000.</p>
<h3 id="bluetooth">Bluetooth</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLUETOOTH</span>
</code></pre>
<p>Enable the Bluetooth serial interface. For boards based on the AT90USB.</p>
<p><img src="//marlinfw.org/assets/images/config/motherboard.jpg" alt="Motherboard">{: .floater}</p>
<h3 id="motherboard">Motherboard</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOTHERBOARD BOARD_RAMPS_14_EFB</span>
</code></pre>
<p>The most important setting is Marlin is the motherboard. The firmware needs to know what board it will be running on so it can assign the right functions to all pins and take advantage of the full capabilities of the board. Setting this incorrectly will lead to unpredictable results.</p>
<p>Using <code>boards.h</code> as a reference, replace <code>BOARD_RAMPS_14_EFB</code> with your board&#39;s ID. The <code>boards.h</code> file has the most up-to-date listing of supported boards, so check it first if you don&#39;t see yours listed here.</p>
<p><table id="board_list" class="table table-condensed table-striped"></table></p>
<script type="text/javascript">
  head.ready("sheetrock.min.js", function() {
    // Load an entire worksheet.
    $('#board_list').sheetrock({
      url: "https://docs.google.com/spreadsheets/d/" +
        "1K4e1GaA4xuNfUGyIw57vxPGuUzQSv5wktTQBHdCVCKU#gid=525308416",
    });
  });
</script>

<p>{% alert info %}
The Sanguino board requires adding &quot;Sanguino&quot; support to Arduino IDE. Open <code>Preferences</code> and locate the <code>Additional Boards Manager URLs</code> field. Copy and paste <a href="https://raw.githubusercontent.com/Lauszus/Sanguino/master/package_lauszus_sanguino_index.json">this source URL</a>. Then use <code>Tools</code> &gt; <code>Boards</code> &gt; <code>Boards Manager</code> to install &quot;Sanguino&quot; from the list. An internet connection is required. (Thanks to <a href="http://dustsreprap.blogspot.my/2015/06/better-way-to-install-sanguino-in.html">Dust&#39;s RepRap Blog</a> for the tip.)
{% endalert %}</p>
<h3 id="custom-machine-name">Custom Machine Name</h3>
<pre><code class="lang-cpp hljs">//<span class="hljs-meta">#define CUSTOM_MACHINE_NAME <span class="hljs-string">"3D Printer"</span></span>
</code></pre>
<p>This is the name of your printer as displayed on the LCD and by <code>M115</code>. For example, if you set this to &quot;My Delta&quot; the LCD will display &quot;My Delta ready&quot; when the printer starts up.</p>
<h3 id="machine-uuid">Machine UUID</h3>
<pre><code class="lang-cpp hljs">//#define MACHINE_UUID "00000000<span class="hljs-string">-0000</span><span class="hljs-string">-0000</span><span class="hljs-string">-0000</span><span class="hljs-string">-000000000000</span>"
</code></pre>
<p>A unique ID for your 3D printer. A suitable unique ID can be generated randomly at <a href="http://www.uuidgenerator.net/version4">uuidgenerator.net</a>. Some host programs and slicers may use this identifier to differentiate between specific machines on your network.</p>
<h2 id="extruder-info">Extruder Info</h2>
<p><a href="https://www.youtube.com/watch?v=ocgPAAJouPs"><img src="//marlinfw.org/assets/images/config/extruders.png" alt="Extruders">{: .floater.framed}</a>{:target=&quot;_blank&quot;}</p>
<h3 id="extruders">Extruders</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXTRUDERS 1</span>
</code></pre>
<p>This value, from 1 to 4, defines how many extruders (or E steppers) the printer has. By default Marlin will assume separate nozzles all moving together on a single carriage. If you have a single nozzle, a switching extruder, a mixing extruder, or dual X carriages, specify that below.</p>
<p>This value should be set to the total number of E stepper motors on the machine, even if there&#39;s only a single nozzle.</p>
<h3 id="single-nozzle">Single Nozzle</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SINGLENOZZLE</span>
</code></pre>
<p>Enable <code>SINGLENOZZLE</code> if you have an E3D Cyclops or any other &quot;multi-extruder&quot; system that shares a single nozzle. In a single-nozzle setup, only one filament drive is engaged at a time, and each needs to retract before the next filament can be loaded and begin purging and extruding.</p>
<h3 id="switching-extruder">Switching Extruder</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">//#define SWITCHING_EXTRUDER</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ENABLED(SWITCHING_EXTRUDER)</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWITCHING_EXTRUDER_SERVO_NR 0</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWITCHING_EXTRUDER_SERVO_ANGLES { 0, 90 } <span class="hljs-comment">// Angles for E0, E1</span></span>
  <span class="hljs-comment">//#define HOTEND_OFFSET_Z {0.0, 0.0}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>A Switching Extruder is a dual extruder that uses a single stepper motor to drive two filaments, but only one at a time. The servo is used to switch the side of the extruder that will drive the filament. The E motor also reverses direction for the second filament. Set the servo sub-settings above according to your particular extruder&#39;s setup instructions.</p>
<h3 id="mixing-extruder">Mixing Extruder</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">/**
 * "Mixing Extruder"
 *   - Adds a new code, M165, to set the current mix factors.
 *   - Extends the stepping routines to move multiple steppers in proportion to the mix.
 *   - Optional support for Repetier Host M163, M164, and virtual extruder.
 *   - This implementation supports only a single extruder.
 *   - Enable DIRECT_MIXING_IN_G1 for Pia Taubert's reference implementation
 */</span>
<span class="hljs-comment">//#define MIXING_EXTRUDER</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ENABLED(MIXING_EXTRUDER)</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIXING_STEPPERS 2        <span class="hljs-comment">// Number of steppers in your mixing extruder</span></span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIXING_VIRTUAL_TOOLS 16  <span class="hljs-comment">// Use the Virtual Tool method with M163 and M164</span></span>
  <span class="hljs-comment">//#define DIRECT_MIXING_IN_G1    // Allow ABCDHI mix factors in G1 movement commands</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>A Mixing Extruder uses two or more stepper motors to drive multiple filaments into a mixing chamber, with the mixed filaments extruded from a single nozzle. This option adds the ability to set a mixture, to save mixtures, and to recall mixtures using the <code>T</code> command. The extruder still uses a single E axis, while the current mixture is used to determine the proportion of each filament to use. An &quot;experimental&quot; <code>G1</code> direct mixing option is included.</p>
<h3 id="hotend-offsets">Hotend Offsets</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis</span>
</code></pre>
<p>Hotend offsets are needed if your extruder has more than one nozzle. These values specify the offset from the first nozzle to each nozzle. So the first element is always set to 0.0. The next element corresponds to the next nozzle, and so on. Add more offsets if you have 3 or more nozzles.</p>
<h2 id="power-supply">Power Supply</h2>
<p><img src="//marlinfw.org/assets/images/config/atx.jpg" alt="ATX">{: .floater}</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POWER_SUPPLY 1</span>
</code></pre>
<p>Use this option to specify the type of power supply you&#39;re using. Marlin uses this setting to decide how to switch the power supply on and off. The options are None (0), ATX (1), or X-Box 360 (2). For a non-switchable power supply use 0. A common example of this is the power &quot;brick&quot; (like a big laptop power supply). For a PC power supply (ATX) or LED Constant-Voltage Power Supply select 1. These are the most commonly-used power supplies.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define PS_DEFAULT_OFF</span>
</code></pre>
<p>Enable this if you don&#39;t want the power supply to switch on when you turn on the printer. This is for printers that have dual powersupplies. For instance some setups have a separate powersupply for the heaters. In this situation you can save power by leaving the powersupply off until called for. If you don&#39;t know what this is leave it.</p>
<p><img src="//marlinfw.org/assets/images/config/thermal.jpg" alt="Thermometer">{: .floater}</p>
<h2 id="thermal-settings">Thermal Settings</h2>
<h3 id="temperature-sensors">Temperature Sensors</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_SENSOR_0 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_SENSOR_1 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_SENSOR_2 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_SENSOR_3 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_SENSOR_4 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_SENSOR_BED 3</span>
</code></pre>
<p>Temperature sensors are vital components in a 3D printer. Fast and accurate sensors ensure that the temperature will be well controlled, to keep plastic flowing smoothly and to prevent mishaps. Use these settings to specify the hotend and bed temperature sensors. Every 3D printer will have a hotend thermistor, and most will have a bed thermistor.</p>
<p>The listing above these options in <code>Configuration.h</code> contains all the thermistors and thermocouples that Marlin knows and supports. Try to match your brand and model with one of the sensors in the list. If no match is found, use a profile for a similar sensor of the same brand, or try &quot;1&quot; – the generic profile. Each profile is calibrated for a particular temperature sensor so it&#39;s important to be as precise as possible.</p>
<p>{% alert warning %}
It is crucial to obtain accurate temperature measurements. As a last resort, use 100k thermistor for <code>TEMP_SENSOR</code> and <code>TEMP_SENSOR_BED</code> but be highly skeptical of the temperature accuracy.
{% endalert %}</p>
<pre><code class="lang-cpp hljs">// Dummy thermistor <span class="hljs-built_in">constant</span> temperature readings, <span class="hljs-keyword">for</span> use <span class="hljs-keyword">with</span> <span class="hljs-number">998</span> <span class="hljs-keyword">and</span> <span class="hljs-number">999</span>
<span class="hljs-comment">#define DUMMY_THERMISTOR_998_VALUE 25</span>
<span class="hljs-comment">#define DUMMY_THERMISTOR_999_VALUE 100</span>
</code></pre>
<p>Marlin provides two dummy sensors for testing purposes. Set their constant temperature readings here.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">//#define TEMP_SENSOR_1_AS_REDUNDANT</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_REDUNDANT_TEMP_SENSOR_DIFF 10</span>
</code></pre>
<p>Enable this option to use sensor 1 as a redundant sensor for sensor 0. This is an advanced way to protect against temp sensor failure. If the temperature difference between sensors exceeds <code>MAX_REDUNDANT_TEMP_SENSOR_DIFF</code> Marlin will abort the print and disable the heater.</p>
<h3 id="temperature-stability">Temperature Stability</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_RESIDENCY_TIME 10  <span class="hljs-comment">// (seconds)</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_HYSTERESIS 3       <span class="hljs-comment">// (degC) range of +/- temperatures considered "close" to the target one</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_WINDOW 1           <span class="hljs-comment">// (degC) Window around target to start the residency timer x degC early.</span></span>
</code></pre>
<p>Extruders must maintain a stable temperature for <code>TEMP_RESIDENCY_TIME</code> before <code>M109</code> will return success and start the print. Tune what &quot;stable&quot; means using <code>TEMP_HYSTERESIS</code> and <code>TEMP_WINDOW</code>.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_BED_RESIDENCY_TIME 10  <span class="hljs-comment">// (seconds)</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_BED_HYSTERESIS 3       <span class="hljs-comment">// (degC) range of +/- temperatures considered "close" to the target one</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEMP_BED_WINDOW 1           <span class="hljs-comment">// (degC) Window around target to start the residency timer x degC early.</span></span>
</code></pre>
<p>Bed must maintain a stable temperature for <code>TEMP_BED_RESIDENCY_TIME</code> before <code>M109</code> will return success and start the print. Tune what &quot;stable&quot; means using <code>TEMP_BED_HYSTERESIS</code> and <code>TEMP_BED_WINDOW</code>.</p>
<h3 id="temperature-ranges">Temperature Ranges</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_0_MINTEMP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_1_MINTEMP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_2_MINTEMP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_3_MINTEMP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_4_MINTEMP 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BED_MINTEMP 5</span>
</code></pre>
<p>These parameters help prevent the printer from overheating and catching fire. Temperature sensors report abnormally low values when they fail or become disconnected. Set these to the lowest value (in degrees C) that the machine is likely to experience. Indoor temperatures range from 10C-40C, but a value of 0 might be appropriate for an unheated workshop.</p>
<p>If any sensor goes below the minimum temperature set here, Marlin will <strong>shut down the printer</strong> with a &quot;MINTEMP&quot; error.</p>
<p>{% alert error MINTEMP %}
<code>Err: MINTEMP</code>: This error means your thermistor has disconnected or become an open circuit. (Or the machine is just very cold.)
{% endalert %}</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_0_MAXTEMP 285</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_1_MAXTEMP 275</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_2_MAXTEMP 275</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_3_MAXTEMP 275</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEATER_4_MAXTEMP 275</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BED_MAXTEMP 130</span>
</code></pre>
<p>Maximum temperature for each temperature sensor. If Marlin reads a temperature above these values, it will immediately shut down for safety reasons. For the E3D V6 hotend, many use 285 as a maximum value.</p>
<p>{% alert error MAXTEMP %}
<code>Err: MAXTEMP</code>: This error usually means that the temperature sensor wires are shorted together. It may also indicate an issue with the heater MOSFET or relay that is causing it to stay on.
{% endalert %}</p>
<hr>
<h3 id="pid">PID</h3>
<p>Marlin uses PID (Proportional, Integral, Derivative) control (<a href="https://en.wikipedia.org/wiki/PID_controller">Wikipedia</a>) to stabilize the dynamic heating system for the hotends and bed. When PID values are set correctly, heaters reach their target temperatures faster, maintain temperature better, and experience less wear over time.</p>
<p>Most vitally, correct PID settings will prevent excessive overshoot, which is a safety hazard. During PID calibration, use the highest target temperature you intend to use (where overshoots are more critical).</p>
<p>See the <a href="http://reprap.org/wiki/PID_Tuning">PID Tuning</a> topic on the RepRap wiki for detailed instructions on <code>M303</code> auto-tuning. The PID settings should be tuned whenever changing a hotend, temperature sensor, heating element, board, power supply voltage (12v/24v), or anything else related to the high-voltage circuitry.</p>
<hr>
<h4 id="hotend-pid-options">Hotend PID Options</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#</span><span class="bash">define PIDTEMP</span>
<span class="hljs-meta">#</span><span class="bash">define BANG_MAX 255     // limits current to nozzle <span class="hljs-keyword">while</span> <span class="hljs-keyword">in</span> bang-bang mode; 255=full current</span>
<span class="hljs-meta">#</span><span class="bash">define PID_MAX BANG_MAX // limits current to nozzle <span class="hljs-keyword">while</span> PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current</span>
</code></pre>
<p>Disable <code>PIDTEMP</code> if you want to run your heater in bang-bang mode. Bang_bang is a pure binary mode where the heater is either full on or full off. PID control is PWM and in most cases is superior in it&#39;s ability to maintain a stable temperature.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">#if ENABLED(PIDTEMP)</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define PID_AUTOTUNE_MENU</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define PID_DEBUG</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define PID_OPENLOOP 1</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define SLOW_PWM_HEATERS</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define PID_PARAMS_PER_HOTEND</span>
  <span class="hljs-comment">#define PID_FUNCTIONAL_RANGE 10</span>
  <span class="hljs-comment">#define K1 0.95</span>
</code></pre>
<p>Enable <code>PID_AUTOTUNE_MENU</code> to add an option on the LCD to run an Autotune cycle and automatically apply the result. Enable <code>PID_PARAMS_PER_HOTEND</code> if you have more than one extruder and they are different models.</p>
<h4 id="pid-values-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">PID Values <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h4>
<pre><code class="lang-cpp hljs">  <span class="hljs-regexp">//</span> Ultimaker
  <span class="hljs-comment">#define  DEFAULT_Kp 22.2</span>
  <span class="hljs-comment">#define  DEFAULT_Ki 1.08</span>
  <span class="hljs-comment">#define  DEFAULT_Kd 114</span>

  <span class="hljs-regexp">//</span> MakerGear
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define  DEFAULT_Kp 7.0</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define  DEFAULT_Ki 0.1</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define  DEFAULT_Kd 12</span>

  <span class="hljs-regexp">//</span> Mendel Parts V9 on <span class="hljs-number">12</span>V
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define  DEFAULT_Kp 63.0</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define  DEFAULT_Ki 2.25</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define  DEFAULT_Kd 440</span>
</code></pre>
<p>Sample PID values are included for reference, but they won&#39;t apply to most setups. The PID values you get from <code>M303</code> may be very different, but will be better for your specific machine.</p>
<p>{% alert info %}
<code>M301</code> can be used to set Hotend PID and is also accessible through the LCD. <code>M304</code> can be used to set bed PID. <code>M303</code> should be used to tune PID values before using any new hotend components.
{% endalert %}</p>
<hr>
<h4 id="bed-pid-options">Bed PID Options</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define PIDTEMPBED</span>
</code></pre>
<p>Enable <code>PIDTEMPBED</code> to use PID for the bed heater (at the same PWM frequency as the extruders). With the default PID_dT the PWM frequency is 7.689Hz, fine for driving a square wave into a resistive load without significant impact on FET heating. This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater. If your configuration is significantly different than this and you don&#39;t understand the issues involved, you probably shouldn&#39;t use bed PID until it&#39;s verified that your hardware works. Use <code>M303 E-1</code> to tune the bed PID for this option.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BED_POWER 255</span>
</code></pre>
<p>The max power delivered to the bed. All forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis). Setting this to anything other than 255 enables a form of PWM. As with <code>PIDTEMPBED</code>, don&#39;t enable this unless your bed hardware is ok with PWM.</p>
<h4 id="bed-pid-values-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">Bed PID Values <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ENABLED(PIDTEMPBED)</span>

  <span class="hljs-comment">//#define PID_BED_DEBUG // Sends debug data to the serial port.</span>

  <span class="hljs-comment">//120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)</span>
  <span class="hljs-comment">//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  DEFAULT_bedKp 10.00</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  DEFAULT_bedKi .023</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  DEFAULT_bedKd 305.4</span>

  <span class="hljs-comment">//120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)</span>
  <span class="hljs-comment">//from pidautotune</span>
  <span class="hljs-comment">//#define  DEFAULT_bedKp 97.1</span>
  <span class="hljs-comment">//#define  DEFAULT_bedKi 1.41</span>
  <span class="hljs-comment">//#define  DEFAULT_bedKd 1675.16</span>

  <span class="hljs-comment">// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// PIDTEMPBED</span></span>
</code></pre>
<p>Sample Bed PID values are included for reference, but use the result from <code>M303 E-1</code> for your specific machine.</p>
<p><img src="//marlinfw.org/assets/images/config/safety.gif" alt="Safety">{: .floater}</p>
<h3 id="safety">Safety</h3>
<h4 id="prevent-cold-extrusion-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-">Prevent Cold Extrusion <em class="fa fa-sticky-note-o" aria-hidden="true"></em></h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREVENT_COLD_EXTRUSION</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXTRUDE_MINTEMP 170</span>
</code></pre>
<p>So-called &quot;cold extrusion&quot; can damage a machine in several ways, but it usually just results in gouged filament and a jammed extruder. With this option, the extruder motor won&#39;t move if the hotend is below the specified temperature. Override this setting with <code>M302</code> if needed.</p>
<h4 id="prevent-lengthy-extrude">Prevent Lengthy Extrude</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREVENT_LENGTHY_EXTRUDE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXTRUDE_MAXLENGTH 200</span>
</code></pre>
<p>A lengthy extrusion may not damage your machine, but it can be an awful waste of filament. This feature is meant to prevent a typo or glitch in a <code>G1</code> command from extruding some enormous amount of filament. For Bowden setups, the max length should be set greater than or equal to the load/eject length.</p>
<h4 id="thermal-protection">Thermal Protection</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THERMAL_PROTECTION_HOTENDS <span class="hljs-comment">// Enable thermal protection for all extruders</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THERMAL_PROTECTION_BED     <span class="hljs-comment">// Enable thermal protection for the heated bed</span></span>
</code></pre>
<p>Thermal protection is one of the most vital safety features in Marlin, allowing the firmware to catch a bad situation and shut down heaters before it goes too far. Consider what happens when a thermistor comes loose during printing. The firmware sees a low temperature reading so it keeps the heat on. As long as the temperature reading is low, the hotend will continue to heat up indefinitely, leading to smoke, oozing, a ruined print, and possibly even fire.</p>
<p>Marlin offers two levels of thermal protection:</p>
<ol>
<li>Check that the temperature is actually increasing when a heater is on. If the temperature fails to rise enough within a certain time period (by default, 2 degrees in 20 seconds), the machine will shut down with a &quot;<code>Heating failed</code>&quot; error. This will detect a disconnected, loose, or misconfigured thermistor, or a disconnected heater.</li>
<li>Monitor thermal stability. If the measured temperature drifts too far from the target temperature for too long, the machine will shut down with a &quot;<code>Thermal runaway</code>&quot; error. This error may indicate poor contact between thermistor and hot end, poor PID tuning, or a cold environment.</li>
</ol>
<p>More thermal protection options are located in <code>Configuration_adv.h</code>. In most setups these can be left unchanged, but should be tuned as needed to prevent false positives.</p>
<p>{% panel info %}
For false thermal runaways <em>not</em> caused by a loose temperature sensor, try increasing <code>WATCH_TEMP_PERIOD</code> or decreasing <code>WATCH_TEMP_INCREASE</code>. Heating may be slowed in a cold environment, if a fan is blowing on the thermistor, or if the heater has high resistance.
{% endpanel %}</p>
<p><img src="//marlinfw.org/assets/images/config/kinematics.jpg" alt="Kinematics">{: .floater}</p>
<h2 id="kinematics">Kinematics</h2>
<p>Marlin supports four kinematic motion systems: Cartesian, Core (H-Bot), Delta, and SCARA. Cartesian is the simplest, applying each stepper directly to an axis. CoreXY uses a special belt arrangement to do XY motion, requiring a little extra maths. Delta robots convert the motion of three vertical carriages into XYZ motion in an &quot;effector&quot; attached to the carriages by six arms. SCARA robots move an arm in the XY plane using two angular joints.</p>
<h3 id="corexy">CoreXY</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define COREXY</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define COREXZ</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define COREYZ</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define COREYX</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define COREZX</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define COREZY</span>
</code></pre>
<p>Enable the option that applies to the specific Core setup. Both normal and reversed options are included for completeness.</p>
<h3 id="delta">Delta</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define DELTA</span>
</code></pre>
<p>For Delta use one of the sample configurations in the <code>example_configurations/delta</code> folder as a starting point.</p>
<h3 id="scara">SCARA</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define SCARA</span>
</code></pre>
<p>For SCARA use the sample configuration in the <code>example_configurations/SCARA</code> folder as a starting point.</p>
<p><img src="//marlinfw.org/assets/images/config/endstop.jpg" alt="Endstop switch">{: .floater}</p>
<h2 id="endstops">Endstops</h2>
<p>In open loop systems, endstops are an inexpensive way to establish the actual position of the carriage on all axes. In the procedure known as &quot;homing,&quot; each axis is moved towards one end until the endstop switch is triggered, at which point the machine knows that the axis is at the endstop (home) position. From this point on, the machine &quot;knows&quot; its position by keeping track of how far the steppers have been moved. If the machine gets out of step for any reason, re-homing may be required.</p>
<h3 id="endstop-plugs">Endstop Plugs</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USE_XMIN_PLUG</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USE_YMIN_PLUG</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USE_ZMIN_PLUG</span>
<span class="hljs-comment">//#define USE_XMAX_PLUG</span>
<span class="hljs-comment">//#define USE_YMAX_PLUG</span>
<span class="hljs-comment">//#define USE_ZMAX_PLUG</span>
</code></pre>
<p>Specify all the endstop connectors that are connected to any endstop or probe. Most printers will use all three min plugs. On delta machines, all the max plugs should be used. Probes can share the Z min plug, or can use one or more of the extra connectors. Don&#39;t enable plugs used for non-endstop and non-probe purposes here.</p>
<h3 id="endstop-pullups">Endstop Pullups</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">#define ENDSTOPPULLUPS</span>

<span class="hljs-comment">#if DISABLED(ENDSTOPPULLUPS)</span>
  <span class="hljs-regexp">//</span> fine endstop settings: Individual pullups. will be ignored <span class="hljs-keyword">if</span> ENDSTOPPULLUPS is defined
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOPPULLUP_XMAX</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOPPULLUP_YMAX</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOPPULLUP_ZMAX</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOPPULLUP_XMIN</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOPPULLUP_YMIN</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOPPULLUP_ZMIN</span>
  <span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOPPULLUP_ZMIN_PROBE</span>
<span class="hljs-comment">#endif</span>
</code></pre>
<p>By default all endstops have pullup resistors enabled. This is best for NC switches, preventing the values from &quot;floating.&quot; If only some endstops should have pullup resistors, you can disable <code>ENDSTOPPULLUPS</code> and enable pullups individually.</p>
<h3 id="endstop-inverting">Endstop Inverting</h3>
<pre><code class="lang-cpp hljs">// Mechanical endstop <span class="hljs-keyword">with</span> COM <span class="hljs-keyword">to</span> ground <span class="hljs-keyword">and</span> NC <span class="hljs-keyword">to</span> <span class="hljs-keyword">Signal</span> uses <span class="hljs-string">"false"</span> here (most common setup).
#define X_MIN_ENDSTOP_INVERTING <span class="hljs-literal">false</span> // set <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">to</span> invert the logic <span class="hljs-keyword">of</span> the endstop.
#define Y_MIN_ENDSTOP_INVERTING <span class="hljs-literal">false</span> // set <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">to</span> invert the logic <span class="hljs-keyword">of</span> the endstop.
#define Z_MIN_ENDSTOP_INVERTING <span class="hljs-literal">false</span> // set <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">to</span> invert the logic <span class="hljs-keyword">of</span> the endstop.
#define X_MAX_ENDSTOP_INVERTING <span class="hljs-literal">false</span> // set <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">to</span> invert the logic <span class="hljs-keyword">of</span> the endstop.
#define Y_MAX_ENDSTOP_INVERTING <span class="hljs-literal">false</span> // set <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">to</span> invert the logic <span class="hljs-keyword">of</span> the endstop.
#define Z_MAX_ENDSTOP_INVERTING <span class="hljs-literal">false</span> // set <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">to</span> invert the logic <span class="hljs-keyword">of</span> the endstop.
#define Z_MIN_PROBE_ENDSTOP_INVERTING <span class="hljs-literal">false</span> // set <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">to</span> invert the logic <span class="hljs-keyword">of</span> the endstop.
</code></pre>
<p>Use <code>M119</code> to test if these are set correctly. If an endstop shows up as &quot;TRIGGERED&quot; when not pressed, and &quot;open&quot; when pressed, then it should be inverted here.</p>
<h3 id="endstop-interrupts">Endstop Interrupts</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define ENDSTOP_INTERRUPTS_FEATURE</span>
</code></pre>
<p>Enable this feature if all enabled endstop pins are interrupt-capable.
This will remove the need to poll the interrupt pins, saving many CPU cycles.</p>
<p><img src="//marlinfw.org/assets/images/config/movement.png" alt="Movement">{: .floater}</p>
<h2 id="movement">Movement</h2>
<h3 id="distinct-e-factors">Distinct E Factors</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define DISTINCT_E_FACTORS</span>
</code></pre>
<p>Enable <code>DISTINCT_E_FACTORS</code> if your extruders are not all mechanically identical. With this setting you can optionally specify different steps-per-mm, max feedrate, and max acceleration for each extruder.</p>
<h3 id="default-steps-per-mm-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">Default Steps per mm <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h3>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">/**
 * Default Axis Steps Per Unit (steps/mm)
 * Override with M92
 *                                      X, Y, Z, E0 [, E1[, E2[, E3[, E4]]]]
 */</span>
#define DEFAULT_AXIS_STEPS_PER_UNIT   { <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">500</span> }
</code></pre>
<p>These are the most crucial settings for your printer, as they determine how accurately the steppers will position the axes. Here we&#39;re telling the firmware how many individual steps produce a single millimeter (or degree on SCARA) of movement. These depend on various factors, including belt pitch, number of teeth on the pulley, thread pitch on leadscrews, micro-stepping settings, and extruder style.</p>
<p>A useful trick is to let the compiler do the calculations for you and just supply the raw values. For example:</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEMA17_FULL_STEPS 200.0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEMA17_MICROSTEPS 16.0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEMA17_MOTOR_STEPS (NEMA17_FULL_STEPS * NEMA17_MICROSTEPS)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PULLEY_PITCH 2.0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PULLEY_TEETH 20.0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_ROD_PITCH 0.8</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WADE_PULLEY_TEETH 11.0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WADE_GEAR_TEETH 45.0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HOBBED_BOLT_DIAM 6.0</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XY_STEPS (NEMA17_MOTOR_STEPS / (PULLEY_PITCH * PULLEY_TEETH))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_STEPS (NEMA17_MOTOR_STEPS / Z_ROD_PITCH)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WADE_GEAR_RATIO (WADE_GEAR_TEETH / WADE_PULLEY_TEETH)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HOBBED_BOLD_CIRC (M_PI * HOBBED_BOLT_DIAM)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WADE_E_STEPS (NEMA17_MOTOR_STEPS * WADE_GEAR_RATIO / HOBBED_BOLD_CIRC)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AXIS_STEPS_PER_UNIT   { XY_STEPS, XY_STEPS, Z_STEPS, ENG2_E_STEPS }</span>
</code></pre>
<p>{% panel info Step Calculator %}
The <a href="http://prusaprinters.org/calculator/">Prusa Calculator</a> is a great tool to help find the right values for your specific printer configuration.
{% endpanel %}</p>
<h4 id="default-max-feed-rate-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">Default Max Feed Rate <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h4>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">/**
 * Default Max Feed Rate (mm/s)
 * Override with M203
 *                                      X, Y, Z, E0 [, E1[, E2[, E3[, E4]]]]
 */</span>
#define DEFAULT_MAX_FEEDRATE { <span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">2.25</span>, <span class="hljs-number">45</span> }
</code></pre>
<p>In any move, the velocities (in mm/sec) in the X, Y, Z, and E directions will be limited to the corresponding <code>DEFAULT_MAX_FEEDRATE</code>.</p>
<p>{% alert danger %}
Setting these too high will cause the corresponding stepper motor to lose steps, especially on high speed movements.
{% endalert %}</p>
<h3 id="acceleration">Acceleration</h3>
<h4 id="default-max-acceleration-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">Default Max Acceleration <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h4>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">/**
 * Default Max Acceleration (change/s) change = mm/s
 * (Maximum start speed for accelerated moves)
 * Override with M201
 *                                      X, Y, Z, E0 [, E1[, E2[, E3[, E4]]]]
 */</span>
#define DEFAULT_MAX_ACCELERATION      { <span class="hljs-number">3000</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10000</span> }
</code></pre>
<p>When the velocity of any axis changes, its acceleration (or deceleration) in mm/s/s is limited by the current max acceleration setting. Also see the <em>jerk</em> settings below, which specify the largest instant speed change that can occur between segments.</p>
<p>A value of 3000 means that an axis may accelerate from 0 to 3000mm/m (50mm/s) within a one second movement.</p>
<p>Jerk sets the floor for accelerated moves. If the change in top speed for a given axis between segments is less than the jerk value for the axis, an instantaneous change in speed may be allowed. Limits placed on other axes also apply. Basically, lower jerk values result in more accelerated moves, which may be near-instantaneous in some cases, depending on the final acceleration determined by the planner.</p>
<h4 id="default-acceleration-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">Default Acceleration <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h4>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">/**
 * Default Acceleration (change/s) change = mm/s
 * Override with M204
 *
 *   M204 P    Acceleration
 *   M204 R    Retract Acceleration
 *   M204 T    Travel Acceleration
 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_ACCELERATION          3000    <span class="hljs-comment">// X, Y, Z and E acceleration for printing moves</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_RETRACT_ACCELERATION  3000    <span class="hljs-comment">// E acceleration for retracts</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_TRAVEL_ACCELERATION   3000    <span class="hljs-comment">// X, Y, Z acceleration for travel (non printing) moves</span></span>
</code></pre>
<p>The planner uses the default accelerations set here (or by <code>M204</code>) as the starting values for movement acceleration, and then constrains them further, if needed. There are separate default acceleration values for printing moves, retraction moves, and travel moves.</p>
<ul>
<li>Printing moves include E plus at least one of the XYZ axes.</li>
<li>Retraction moves include only the E axis.</li>
<li>Travel moves include only the XYZ axes.</li>
</ul>
<p>In print/travel moves, <code>DEFAULT_ACCELERATION</code> and <code>DEFAULT_TRAVEL_ACCELERATION</code> apply to the XYZ axes. In retraction moves, <code>DEFAULT_RETRACT_ACCELERATION</code> applies only to the <em>E</em>-axis. During movement planning, Marlin constrains the default accelerations to the maximum acceleration of all axes involved in the move.</p>
<p>{% alert danger %}
Don&#39;t set these too high. Larger acceleration values can lead to excessive vibration, noisy steppers, or even skipped steps. Lower acceleration produces smoother motion, eliminates vibration, and helps reduce wear on mechanical parts.
{% endalert %}</p>
<hr>
<h4 id="jerk-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">Jerk <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h4>
<pre><code class="lang-cpp hljs">/**
 * Default Jerk (mm/s)
 * Override <span class="hljs-keyword">with</span> M205 X Y Z E
 *
 * <span class="hljs-string">"Jerk"</span> specifies <span class="hljs-keyword">the</span> minimum speed change <span class="hljs-keyword">that</span> requires acceleration.
 * When changing speed <span class="hljs-keyword">and</span> direction, <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> difference <span class="hljs-keyword">is</span> <span class="hljs-keyword">less than</span> <span class="hljs-keyword">the</span>
 * value <span class="hljs-keyword">set</span> here, <span class="hljs-keyword">it</span> may happen instantaneously.
 */
<span class="hljs-comment">#define DEFAULT_XJERK                 20.0</span>
<span class="hljs-comment">#define DEFAULT_YJERK                 20.0</span>
<span class="hljs-comment">#define DEFAULT_ZJERK                  0.4</span>
<span class="hljs-comment">#define DEFAULT_EJERK                  5.0</span>
</code></pre>
<p>Jerk works in conjunction with acceleration (see above). Jerk is the maximum change in velocity (in mm/sec) that can occur instantaneously. It can also be thought of as the minimum change in velocity that will be done as an accelerated (not instantaneous) move.</p>
<p>Both acceleration and jerk affect your print quality. If jerk is too low, the extruder will linger too long on small segments and corners, possibly leaving blobs. If the jerk is set too high, direction changes will apply too much torque and you may see &quot;ringing&quot; artifacts or dropped steps.</p>
<h2 id="z-probe-options">Z Probe Options</h2>
<p><img src="//marlinfw.org/assets/images/config/probe.jpg" alt="Probe">{: .floater.framed}</p>
<h3 id="probe-pins">Probe Pins</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define Z_MIN_PROBE_ENDSTOP</span>
</code></pre>
<p>If you want to use both probe and end-switch for homing and endstop, enable this. However, This requires extra setups to be done. If you&#39;re using Ramps 1.4, the probe pins are located in D32 of the aux4 array that is also used by the lcd panel. You will have to change the pin assignments from your specified board pin file (for example &quot;pins_RAMPS_14.h&quot;) located at <code>#define Z_MIN_PROBE_PIN  32</code>. I would change this to pin 19 (z max) since it is rarely if ever used. This extra port is actually the Z Probe that is used for your auto bed leveling.</p>
<p>Another way is to change between these pins: <code>#define Z_MIN_PROBE_PIN  32</code>, <code>#define Z_MIN_PIN 18</code>, and <code>#define Z_MAX_PIN 19</code>  according to your board. This is not for beginners.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN</span>
</code></pre>
<p>This uses the same pin for the end-switch and the probe. The advantage is that you don&#39;t need to alter any pin-out assignments, however you can only have ONE active at a time.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define DISABLE_Z_MIN_PROBE_ENDSTOP</span>
</code></pre>
<p>This typically disables your probe feature. Only applicable to <code>//#define Z_MIN_PROBE_ENDSTOP</code> enabled</p>
<h3 id="probe-type">Probe Type</h3>
<p>Marlin supports any kind of probe that can be made to work like a switch. Specific types of probes have different needs.</p>
<h4 id="manual-probe-no-probe-">Manual Probe (no probe)</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define PROBE_MANUALLY</span>
</code></pre>
<p>Even if you have no bed probe you can still use any of the core <code>AUTO_BED_LEVELING_*</code> options below by selecting this option. With <code>PROBE_MANUALLY</code> the <code>G29</code> command only moves the nozzle to the next probe point where it pauses. You adjust the Z height with a piece of paper or feeler gauge, then send <code>G29</code> again to continue to the next point. You can also enable <code>LCD_BED_LEVELING</code> to add a &quot;Level Bed&quot; Menu item to the LCD for a fully interactive leveling process.</p>
<h4 id="fix-mounted-probe">Fix Mounted Probe</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define FIX_MOUNTED_PROBE</span>
</code></pre>
<p>This option is for any probe that&#39;s fixed in place, with no need to be deployed or stowed. Specify this type for an inductive probe or when using the nozzle itself as the probe.</p>
<h4 id="bltouch">BLTouch</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define BLTOUCH</span>
</code></pre>
<p>The <a href="https://plus.google.com/113792662927481823969">ANTCLABS BLTouch</a> probe uses custom circuitry and a magnet to raise and lower a metal pin which acts as a touch probe. The BLTouch uses the servo connector and is controlled using specific servo angles. With this option enabled the other required settings are automatically configured (so there&#39;s no need to enter servo angles, for example).</p>
<h4 id="servo-z-probe">Servo Z Probe</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define Z_ENDSTOP_SERVO_NR 0</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define Z_SERVO_ANGLES {70,0} // Z Servo Deploy and Stow angles</span>
</code></pre>
<p>To indicate a Servo Z Probe (e.g., an endstop switch mounted on a rotating arm) just specify the servo index. Use the <code>M280</code> command to find the best <code>Z_SERVO_ANGLES</code> values.</p>
<h4 id="solenoid-probe">Solenoid Probe</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define SOLENOID_PROBE</span>
</code></pre>
<p>A probe that is deployed and stowed with a solenoid pin (Defined as <code>SOL1_PIN</code>.)</p>
<h4 id="z-probe-sled">Z Probe Sled</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define Z_PROBE_SLED</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define SLED_DOCKING_OFFSET 5</span>
</code></pre>
<p>This type of probe is mounted on a detachable &quot;sled&quot; that sits at the far end of the X axis. Before probing, the X carriage moves to the far end and picks up the sled. When probing is completed, it drops the sled off. The <code>SLED_DOCKING_OFFSET</code> specifies the extra distance the X axis must travel to pickup the sled. 0 should be fine but it may be pushed further if needed.</p>
<p>See the <a href="http://www.thingiverse.com/thing:396692">Prusa i3 Z-probe Sled Mount</a> for an example of this kind of probe.</p>
<h4 id="allen-key">Allen Key</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define Z_PROBE_ALLEN_KEY</span>
</code></pre>
<p>A retractable z-probe for deltas that uses an Allen key as the probe. See &quot;<a href="http://reprap.org/wiki/Kossel#Automatic_bed_leveling_probe">Kossel automatic bed leveling probe</a>&quot; at the RepRap wiki. It deploys by leveraging against the z-axis belt, and retracts by pushing the probe down.</p>
<p>More information will be included in an upcoming Delta configuration page.</p>
<h3 id="probe-offsets-em-class-fa-fa-sticky-note-o-aria-hidden-true-em-em-class-fa-fa-desktop-aria-hidden-true-em-">Probe Offsets <em class="fa fa-sticky-note-o" aria-hidden="true"></em> <em class="fa fa-desktop" aria-hidden="true"></em></h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_PROBE_OFFSET_FROM_EXTRUDER -44  <span class="hljs-comment">// X offset: -left  [of the nozzle] +right</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y_PROBE_OFFSET_FROM_EXTRUDER -8  <span class="hljs-comment">// Y offset: -front [of the nozzle] +behind</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_PROBE_OFFSET_FROM_EXTRUDER -2.50   <span class="hljs-comment">// Z offset: -below [the nozzle](for most negative! positive when using tilt probes or the nozzle based probes)</span></span>
</code></pre>
<p>These offsets specify the distance from the tip of the nozzle to the probe — or more precisely, to the point at which the probe triggers. The X and Y offsets are specified as integers. The Z offset should be specified as exactly as possible using a decimal value. The Z offset can be overridden with <code>M851 Z</code> or the LCD controller. The <code>M851</code> offset is saved to EEPROM with <code>M500</code>.</p>
<h3 id="probing-speed">Probing Speed</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">// X and Y axis travel speed (mm/m) between probes</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XY_PROBE_SPEED 4000</span>
<span class="hljs-comment">// Speed for the first approach when double-probing (with PROBE_DOUBLE_TOUCH)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_PROBE_SPEED_FAST HOMING_FEEDRATE_Z</span>
<span class="hljs-comment">// Speed for the "accurate" probe of each point</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_PROBE_SPEED_SLOW (Z_PROBE_SPEED_FAST / 2)</span>
</code></pre>
<p>Probing should be done quickly, but the Z speed should be tuned for best repeatability. Depending on the probe, a slower Z probing speed may be needed for repeatable results.</p>
<h3 id="probe-double-touch">Probe Double Touch</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span> Use double touch <span class="hljs-keyword">for</span> probing
<span class="hljs-regexp">//</span><span class="hljs-comment">#define PROBE_DOUBLE_TOUCH</span>
</code></pre>
<p>Some probes may be more accurate with this option, which causes all probes to be done twice — first fast, then slow. The second result is used as the measured Z position.</p>
<h3 id="probe-clearance">Probe Clearance</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_CLEARANCE_DEPLOY_PROBE   10 <span class="hljs-comment">// Z Clearance for Deploy/Stow</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_CLEARANCE_BETWEEN_PROBES  5 <span class="hljs-comment">// Z Clearance between probe points</span></span>
</code></pre>
<p>Z probes require clearance when deploying, stowing, and moving between probe points to avoid hitting the bed and other hardware. Servo-mounted probes require extra space for the arm to rotate. Inductive probes need space to keep from triggering early.</p>
<p>Use these settings to specify the distance (mm) to raise the probe (or lower the bed). The values set here apply over and above any (negative) probe Z Offset set with <code>Z_PROBE_OFFSET_FROM_EXTRUDER</code>, <code>M851</code>, or the LCD. Only integer values &gt;= 1 are valid for these settings.</p>
<ul>
<li><em>Example</em>: <code>M851 Z-5</code> with a CLEARANCE of 4  =&gt;  9mm from bed to nozzle.</li>
<li><em>But</em>: <code>M851 Z+1</code> with a CLEARANCE of 2  =&gt;  2mm from bed to nozzle.</li>
</ul>
<p>{% panel warning G29 Movement %}
Make sure you have enough clearance for the probe to move between points!
{% endpanel %}</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_PROBE_OFFSET_RANGE_MIN -20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_PROBE_OFFSET_RANGE_MAX 20</span>
</code></pre>
<p>For <code>M851</code> and LCD menus give a range for adjusting the Z probe offset.</p>
<h3 id="probe-testing">Probe Testing</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_MIN_PROBE_REPEATABILITY_TEST</span>
</code></pre>
<p>This enables you to test the reliability of your probe.
Issue a M48 command to start testing. It will give you a standard deviation for the probe.
Tip: 0.02 mm is normally acceptable for bed leveling to work.</p>
<p><img src="//marlinfw.org/assets/images/config/motor-dir.jpg" alt="Stepper Spin">{: .floater}</p>
<h2 id="stepper-drivers">Stepper Drivers</h2>
<h3 id="motor-enable">Motor Enable</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_ENABLE_ON 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y_ENABLE_ON 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_ENABLE_ON 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> E_ENABLE_ON 0 <span class="hljs-comment">// For all extruders</span></span>
</code></pre>
<p>These options set the pin states used for stepper enable. The most common setting is 0 (<code>LOW</code>) for Active Low. For Active High use 1 or <code>HIGH</code>.</p>
<h3 id="motor-disable">Motor Disable</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#</span><span class="bash">define DISABLE_X <span class="hljs-literal">false</span></span>
<span class="hljs-meta">#</span><span class="bash">define DISABLE_Y <span class="hljs-literal">false</span></span>
<span class="hljs-meta">#</span><span class="bash">define DISABLE_Z <span class="hljs-literal">false</span></span>
</code></pre>
<p>Use these options to disable steppers when not being issued a movement. This was implemented as a hack to run steppers at higher-than-normal current in an effort to produce more torque at the cost of increased heat for drivers and steppers.</p>
<p>Disabling the steppers between moves gives the motors and drivers a chance to cool off. It sounds good in theory, but in practice it has drawbacks. Disabled steppers can&#39;t hold the carriage stable. This results in poor accuracy and carries a strong probability of axial drift (i.e., lost steps).</p>
<p>Most 3D printers use an &quot;open loop&quot; control system, meaning the software can&#39;t ascertain the actual carriage position at a given time. It simply sends commands and assumes they have been obeyed. In practice with a well-calibrated machine this is not an issue and using open loop is a major cost saving with excellent quality.</p>
<p>We don&#39;t recommend this hack. There are much better ways to address the problem of stepper/driver overheating. Some examples: stepper/driver heatsink, active cooling, dual motors on the axis, reduce microstepping, check belt for over tension, check components for smooth motion, etc.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define DISABLE_REDUCED_ACCURACY_WARNING</span>
</code></pre>
<p>Enable this option to suppress the warning given in cases when reduced accuracy is likely to occur.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#</span><span class="bash">define DISABLE_E <span class="hljs-literal">false</span> // For all extruders</span>
<span class="hljs-meta">#</span><span class="bash">define DISABLE_INACTIVE_EXTRUDER <span class="hljs-literal">true</span> //<span class="hljs-built_in">disable</span> only inactive extruders and keep active extruder enabled</span>
</code></pre>
<p>The E disable option works like <code>DISABLE_[XYZ]</code> but pertains to one or more extruders. The default setting keeps the active extruder enabled, disabling all inactive extruders. This is reasonable for situations where a &quot;wipe tower&quot; or other means is used to ensure that the nozzle is primed and not oozing between uses.</p>
<h3 id="motor-direction">Motor Direction</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#</span><span class="bash">define INVERT_X_DIR <span class="hljs-literal">true</span></span>
<span class="hljs-meta">#</span><span class="bash">define INVERT_Y_DIR <span class="hljs-literal">false</span></span>
<span class="hljs-meta">#</span><span class="bash">define INVERT_Z_DIR <span class="hljs-literal">true</span></span>
<span class="hljs-meta">
#</span><span class="bash">define INVERT_E0_DIR <span class="hljs-literal">false</span></span>
<span class="hljs-meta">#</span><span class="bash">define INVERT_E1_DIR <span class="hljs-literal">false</span></span>
<span class="hljs-meta">#</span><span class="bash">define INVERT_E2_DIR <span class="hljs-literal">false</span></span>
<span class="hljs-meta">#</span><span class="bash">define INVERT_E3_DIR <span class="hljs-literal">false</span></span>
<span class="hljs-meta">#</span><span class="bash">define INVERT_E4_DIR <span class="hljs-literal">false</span></span>
</code></pre>
<p>These settings reverse the motor direction for each axis. Be careful when first setting these. Axes moving the wrong direction can cause damage. Get these right without belts attached first, if possible. Before testing, move the carriage and bed to the middle. Test each axis for proper movemnt using the host or LCD &quot;Move Axis&quot; menu. If an axis is inverted, either flip the plug around or change its invert setting.</p>
<h3 id="toshiba-drivers">Toshiba Drivers</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span> Enable this option <span class="hljs-keyword">for</span> Toshiba stepper drivers
<span class="hljs-regexp">//</span><span class="hljs-comment">#define CONFIG_STEPPERS_TOSHIBA</span>
</code></pre>
<p>Leave this option disabled for typical stepper drivers such as A4988 or DVR8825.</p>
<h2 id="homing-and-bounds">Homing and Bounds</h2>
<h3 id="z-homing-height">Z Homing Height</h3>
<p><img src="//marlinfw.org/assets/images/config/home.jpg" alt="Home Icon">{: .floater}</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define Z_HOMING_HEIGHT 4</span>
</code></pre>
<p>This value raises Z to the specified height above the bed before homing X or Y. This is useful to prevent the head crashing into bed mountings such as screws, bulldog clips, etc. This also works with auto bed leveling enabled and will be triggered only when the Z axis height is less than the defined value, otherwise the Z axis will not move.</p>
<h3 id="homing-direction">Homing Direction</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_HOME_DIR -1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y_HOME_DIR -1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_HOME_DIR -1</span>
</code></pre>
<p>Homing direction for each axis: -1 = min, 1 = max. Most cartesian and core machines have three min endstops. Deltas have three max endstops. For other configurations set these values appropriately.</p>
<h3 id="software-endstops">Software Endstops</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_SOFTWARE_ENDSTOPS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SOFTWARE_ENDSTOPS</span>
</code></pre>
<p>Set to <code>true</code> to enable the option to constrain movement to the physical boundaries of the machine (as set by <code>[XYZ]_(MIN|MAX)_POS</code>). For example, <code>G1 Z-100</code> can be min constrained to <code>G1 Z0</code>. It is recommended to enable these options as a safety feature. If software endstops need to be disabled, use <code>M211 S0</code>.</p>
<h3 id="movement-bounds">Movement Bounds</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_MIN_POS 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y_MIN_POS 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_MIN_POS 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_MAX_POS 200</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y_MAX_POS 200</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z_MAX_POS 170</span>
</code></pre>
<p>These values specify the physical limits of the machine. Usually the <code>[XYZ]_MIN_POS</code> values are set to 0, because endstops are positioned at the bed limits. <code>[XYZ]_MAX_POS</code> should be set to the farthest reachable point. By default, these positions are used for homing as well. However, the <code>MANUAL_[XYZ]_HOME_POS</code> options can be used to override these, if needed.</p>
<p>{% panel info Home Offset %}
Although home positions are fixed, <code>M206</code> can be used to apply offsets to the home position if needed.
{% endpanel %}</p>
<h2 id="filament-runout-sensor">Filament Runout Sensor</h2>
<p><img src="//marlinfw.org/assets/images/config/filament-sensor.jpg" alt="Filament Sensor">{: .floater.framed}</p>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">//#define FILAMENT_RUNOUT_SENSOR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ENABLED(FILAMENT_RUNOUT_SENSOR)</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIL_RUNOUT_INVERTING false <span class="hljs-comment">// set to true to invert the logic of the sensor.</span></span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ENDSTOPPULLUP_FIL_RUNOUT <span class="hljs-comment">// Uncomment to use internal pullup for filament runout pins if the sensor is defined.</span></span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILAMENT_RUNOUT_SCRIPT <span class="hljs-meta-string">"M600"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>With this feature, a mechanical or opto endstop switch is used to check for the presence of filament in the feeder (usually the switch is closed when filament is present). If the filament runs out, Marlin will run the specified GCode script (by default &quot;<code>M600</code>&quot;). RAMPS-based boards use <code>SERVO3_PIN</code>. For other boards you may need to define <code>FIL_RUNOUT_PIN</code>.</p>
<h2 id="bed-leveling">Bed Leveling</h2>
<p><img src="//marlinfw.org/assets/images/config/bedlevel.png" alt="Bed Level">{: .floater}</p>
<p>There are many cases where it&#39;s useful to measure variances in bed height. Even if the bed on a 3D printer is perfectly flat and level, there may still be imperfections in the mechanics. For example, a machine may have a very flat bed, but a corner of the XY gantry is a half-mm high. The ends of the Z axis may not be perfectly level. The bed may move slightly in the Z plane as it moves in the X and/or Y plane. On a Delta there may be a lingering bowl-shape to its XY trajectory.</p>
<p>Bed Compensation or &quot;--- Bed Leveling&quot; allows the machine —with a bed probe or user assistance— to take accurate measurements of the &quot;bed height&quot; at various points in the XY plane. With this data the machine can then adjust movement to align better to the tilt or &quot;height&quot; variances in the bed. (I&#39;m scare-quoting &quot;height&quot; here because variances may come from other than the bed.)</p>
<p>For more details on these features, see <a href="/docs/gcode/G029-mbl.html"><code>G29</code> for MBL</a> and <a href="/docs/gcode/G029-abl.html"><code>G29</code> for ABL</a>.</p>
<h3 id="debug-leveling">Debug Leveling</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define DEBUG_LEVELING_FEATURE</span>
</code></pre>
<p>Use this option to enable extra debugging of homing and leveling. You can then use <code>M111 S32</code> before issuing <code>G28</code> and <code>G29 V4</code> to get a detailed log of the process for diagnosis. This option is useful to figure out the cause of unexpected behaviors, or when reporting issues to the project.</p>
<h3 id="leveling-fade-height">Leveling Fade Height</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ENABLE_LEVELING_FADE_HEIGHT</span>
</code></pre>
<p>Available with <code>MESH_BED_LEVELING</code>, <code>AUTO_BED_LEVELING_BILINEAR</code>, and <code>AUTO_BED_LEVELING_UBL</code>.</p>
<p>This option adds the <code>Z</code> parameter to <code>M420</code> which sets a fade distance over which leveling will be gradually reduced. Above the given Z height, leveling compensation will no longer be applied.</p>
<p>This feature exists to prevent irregularities in the bed from propagating through the model&#39;s entire height. Fading out leveling also reduces computational requirements and resonance from the Z axis above the fade height. For a well-aligned machine, this feature can improve print results.</p>
<p>Example: To have leveling fade out over the first 10mm of layer printing use <code>M420 Z10</code>. If each layer is 0.2mm high, leveling compensation will be reduced by 1/50th (2%) after each layer. Above 10mm the machine will move without compensation.</p>
<h3 id="bed-leveling-style">Bed Leveling Style</h3>
<p>Bed Leveling is a standard feature on many 3D printers. It takes the guess-work out of getting a good first layer and good bed adhesion.  All forms of bed leveling add <code>G29</code> Bed Probing, <code>M420</code> enable/disable, and can save their results to EEPROM with <code>M500</code>. Bravo!</p>
<p>With Bed Leveling enabled:</p>
<ul>
<li><code>G28</code> disables bed leveling, but leaves previous leveling data intact.</li>
<li><code>G29</code> automatically or manually probes the bed at various points, measures the bed height, calculates a correction grid or matrix, and turns on leveling compensation. Specific behavior depends on configuration and type of bed leveling.</li>
<li><code>M500</code> saves the bed leveling data to EEPROM. Use <code>M501</code> to load it, <code>M502</code> to clear it, and <code>M503</code> to report it.</li>
<li><code>M420 S&lt;bool&gt;</code> can be used to enable/disable bed leveling. For example, <code>M420 S1</code> must be used after <code>M501</code> to enable the loaded mesh or matrix, and to re-enable leveling after <code>G28</code>, which disables leveling compensation.</li>
<li>A &quot;Level Bed&quot; menu item can be added to the LCD with the <code>LCD_BED_LEVELING</code> option.</li>
</ul>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define AUTO_BED_LEVELING_3POINT</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define AUTO_BED_LEVELING_LINEAR</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define AUTO_BED_LEVELING_BILINEAR</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define AUTO_BED_LEVELING_UBL</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define MESH_BED_LEVELING</span>
</code></pre>
<p>Enable just one type of Bed Leveling.</p>
<ul>
<li><code>AUTO_BED_LEVELING_3POINT</code> probes three points in a triangle. The flat plane gives a transform matrix suitable to compensate for a flat but tilted bed.</li>
<li><code>AUTO_BED_LEVELING_LINEAR</code> probes the bed in a grid. A transform matrix is produced by least-squares method to compensate for a flat but tilted bed.</li>
<li><code>AUTO_BED_LEVELING_BILINEAR</code> probes the bed in a grid, with optional Catmull-Rom subdivision. The mesh data is used to adjust Z height across the bed using bilinear interpolation. Good for delta, large, or uneven beds.</li>
<li><code>AUTO_BED_LEVELING_UBL</code> (recommended) combines the features of 3-point, linear, bilinear, and mesh leveling. As with bilinear leveling, the mesh data generated by UBL is used to adjust Z height across the bed using bilinear interpolation. An LCD controller is currently required.</li>
<li><code>MESH_BED_LEVELING</code> provides a custom <code>G29</code> command to measure the bed height at several grid points using a piece of paper or feeler gauge. See <a href="/docs/gcode/G029-mbl.html"><code>G29</code> for MBL</a> for the full procedure. This type of leveling is only compatible with <code>PROBE_MANUALLY</code>.</li>
</ul>
<p>{% alert info %}
Only <code>AUTO_BED_LEVELING_BILINEAR</code> and <code>AUTO_BED_LEVELING_UBL</code> support <code>DELTA</code>.<br/>
Only <code>AUTO_BED_LEVELING_BILINEAR</code> currently supports <code>SCARA</code>.<br/>
<code>MESH_BED_LEVELING</code> is incompatible with Delta and SCARA.
{% endalert %}</p>
<h3 id="linear-bilinear-options">Linear / Bilinear Options</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEFT_PROBE_BED_POSITION 15</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RIGHT_PROBE_BED_POSITION 145</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FRONT_PROBE_BED_POSITION 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BACK_PROBE_BED_POSITION 150</span>
</code></pre>
<p>These settings specify the boundaries for probing with <code>G29</code>. This will most likely be a sub-section of the bed because probes are not usually able to reach every point that the nozzle can. Take account of the probe&#39;s XY offsets when setting these boundaries.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRID_MAX_POINTS_X 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRID_MAX_POINTS_Y GRID_MAX_POINTS_X</span>
</code></pre>
<p>These options specify the default number of points to probe in each dimension during <code>G29</code>.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define PROBE_Y_FIRST</span>
</code></pre>
<p>Enable this option if probing should proceed in the Y dimension first instead of X first.</p>
<h3 id="bilinear-options">Bilinear Options</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define EXTRAPOLATE_BEYOND_GRID</span>
</code></pre>
<p>Usually the probed grid doesn&#39;t extend all the way to the edges of the bed. So, outside the bounds of the probed grid, Z adjustment can take one of two approaches. Either the Z height can continue to raise/lower by the established tilt of the nearest grid box (best when most of the bed was probed), or it can follow the contour of the nearest edge (the default). Enable this option for extrapolation.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">//#define ABL_BILINEAR_SUBDIVISION</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ENABLED(ABL_BILINEAR_SUBDIVISION)</span>
  <span class="hljs-comment">// Number of subdivisions between probe points</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BILINEAR_SUBDIVISIONS 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>If you have SRAM to spare, this option will multiply the resolution of the bilinear grid using the Catmull-Rom subdivision method. This option only applies to bilinear leveling. If the default value of 3 is too expensive, try 2 or 1. (In Marlin 1.1.1, the default grid will be stored in PROGMEM, as UBL now does.)</p>
<h3 id="3-point-options">3-Point Options</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ABL_PROBE_PT_1_X 15</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ABL_PROBE_PT_1_Y 180</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ABL_PROBE_PT_2_X 15</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ABL_PROBE_PT_2_Y 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ABL_PROBE_PT_3_X 170</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ABL_PROBE_PT_3_Y 20</span>
</code></pre>
<p>These options specify the three points that will be probed during <code>G29</code>.</p>
<h3 id="unified-bed-leveling-options">Unified Bed Leveling Options</h3>
<h4 id="probe-points">Probe Points</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UBL_MESH_INSET 1          <span class="hljs-comment">// Mesh inset margin on print area</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRID_MAX_POINTS_X 10      <span class="hljs-comment">// Don't use more than 15 points per axis, implementation limited.</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRID_MAX_POINTS_Y GRID_MAX_POINTS_X</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UBL_PROBE_PT_1_X 39       <span class="hljs-comment">// These set the probe locations for when UBL does a 3-Point leveling</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UBL_PROBE_PT_1_Y 180      <span class="hljs-comment">// of the mesh.</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UBL_PROBE_PT_2_X 39</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UBL_PROBE_PT_2_Y 20</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UBL_PROBE_PT_3_X 180</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UBL_PROBE_PT_3_Y 20</span>
</code></pre>
<p>These options specify the inset, grid, and 3-point triangle to use for UBL. Note that probe XY offsets and movement limits may constrain the probeable area of the bed.</p>
<h4 id="g26-mesh-editing-amp-debugging">G26 Mesh Editing &amp; Debugging</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define UBL_G26_MESH_EDITING</span>
</code></pre>
<p>Enable this option for <code>G26</code> Mesh Editing. (Documentation coming soon!)</p>
<h3 id="mesh-bed-leveling-options">Mesh Bed Leveling Options</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MESH_INSET 10          <span class="hljs-comment">// Mesh inset margin on print area</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRID_MAX_POINTS_X 3    <span class="hljs-comment">// Don't use more than 7 points per axis, implementation limited.</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GRID_MAX_POINTS_Y GRID_MAX_POINTS_X</span>

<span class="hljs-comment">//#define MESH_G28_REST_ORIGIN // After homing all axes ('G28' or 'G28 XYZ') rest Z at Z_MIN_POS</span>
</code></pre>
<p>These options specify the number of points that will always be probed in each dimension during <code>G29</code>. The mesh inset is used to automatically calculate the probe boundaries. These can be set explicitly in <code>Configuration_adv.h</code>. <code>MESH_G28_REST_ORIGIN</code> moves the nozzle to rest at <code>Z_MIN_POS</code> when mesh probing is done. If Z is offset (e.g., due to <code>home_offset</code> or some other cause) this is intended to move Z to a good starting point, usually Z=0.</p>
<h3 id="lcd-bed-leveling">LCD Bed Leveling</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCD_BED_LEVELING</span>
</code></pre>
<p><code>LCD_BED_LEVELING</code> adds a &quot;Level Bed&quot; menu to the LCD that starts a step-by-step guided leveling procedure that requires no probe. For Mesh Bed Leveling see <a href="/docs/gcode/G029-mbl.html"><code>G29</code> for MBL</a>, and for <code>PROBE_MANUALLY</code> see <a href="http://marlinfw.org/docs/gcode/G029-abl.html"><code>G29</code> for ABL</a>.</p>
<p>Available with <code>MESH_BED_LEVELING</code> and <code>PROBE_MANUALLY</code> (all forms of Auto Bed Leveling). See the <code>Configuration.h</code> file for sub-options.</p>
<h3 id="z-probe-end-script">Z Probe End Script</h3>
<pre><code class="lang-cpp hljs">//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000<span class="hljs-symbol">\n</span>G1 X15 Y330<span class="hljs-symbol">\n</span>G1 Z0.5<span class="hljs-symbol">\n</span>G1 Z10"
</code></pre>
<p>A custom script to do at the very end of <code>G29</code>. If multiple commands are needed, divide them with <code>\n</code> (the newline character).</p>
<h2 id="homing-options">Homing Options</h2>
<h3 id="bed-center-at-0-0">Bed Center at 0,0</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define BED_CENTER_AT_0_0</span>
</code></pre>
<p>Enable this option if the bed center is at X0 Y0. This setting affects the way automatic home positions (those not set with <code>MANUAL_[XYZ]_POS</code>) are calculated. This should always be enabled with <code>DELTA</code>.</p>
<h3 id="manual-home-position">Manual Home Position</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define MANUAL_X_HOME_POS 0</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define MANUAL_Y_HOME_POS 0</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define MANUAL_Z_HOME_POS 0 // Distance from nozzle to printbed after homing</span>
</code></pre>
<p>These settings are used to override the home position. Leave them undefined for automatic settings. For <code>DELTA</code> Z home must be set to the top-most position.</p>
<h3 id="z-safe-homing">Z Safe Homing</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#</span><span class="bash">define Z_SAFE_HOMING</span>
<span class="hljs-meta">
#</span><span class="bash"><span class="hljs-keyword">if</span> ENABLED(Z_SAFE_HOMING)</span>
<span class="hljs-meta">  #</span><span class="bash">define Z_SAFE_HOMING_X_POINT ((X_MIN_POS + X_MAX_POS) / 2)    // X point <span class="hljs-keyword">for</span> Z homing when homing all axis (G28).</span>
<span class="hljs-meta">  #</span><span class="bash">define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point <span class="hljs-keyword">for</span> Z homing when homing all axis (G28).</span>
<span class="hljs-meta">#</span><span class="bash">endif</span>
</code></pre>
<p><strong>Z Safe Homing</strong> prevents Z from homing when the probe (or nozzle) is outside bed area by moving to a defined XY point (by default, the middle of the bed) before Z Homing when homing all axes with <code>G28</code>. As a side-effect, X and Y homing are required before Z homing. If stepper drivers time out, X and Y homing will be required again.</p>
<p>Enable this option if a probe (not an endstop) is being used for Z homing. Z Safe Homing isn&#39;t needed if a Z endstop is used for homing, but it may also be enabled just to have XY always move to some custom position after homing.</p>
<h3 id="homing-speed">Homing Speed</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">// Homing speeds (mm/m)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HOMING_FEEDRATE_XY (50*60)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HOMING_FEEDRATE_Z  (4*60)</span>
</code></pre>
<p>Homing speed for use in auto home and auto bed leveling. These values may be set to the fastest speeds your machine can achieve. Homing and probing speeds are constrained by the current max feedrate and max acceleration settings.</p>
<p>{% alert warning %}
Setting these values too high may result in reduced accuracy and/or skipped steps. Reducing acceleration may help to achieve higher top speeds.
{% endalert %}</p>
<hr>
<h2 id="extras-1">Extras 1</h2>
<h3 id="eeprom">EEPROM</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EEPROM_SETTINGS</span>
</code></pre>
<p>Commands like <code>M92</code> only change the settings in volatile memory, and these settings are lost when the machine is powered off. With this option enabled, Marlin uses the built-in EEPROM to preserve settings across reboots. Settings saved to EEPROM (with <code>M500</code>) are loaded automatically whenever the machine restarts (and in most setups, when connecting to a host), overriding the defaults set in the configuration files. This option is highly recommended, as it makes configurations easier to manage.</p>
<p>The EEPROM-related commands are:</p>
<ul>
<li><code>M500</code>: Save all current settings to EEPROM.</li>
<li><code>M501</code>: Load all settings last saved to EEPROM.</li>
<li><code>M502</code>: Reset all settings to their default values (as set by <code>Configuration.h</code>)</li>
<li><code>M503</code>: Print the current settings (in RAM, not EEPROM)</li>
</ul>
<p>{% alert info %}
Settings that can be changed and saved to EEPROM are marked with <em class="fa fa-sticky-note-o" aria-hidden="true"></em>. Options marked with <em class="fa fa-desktop" aria-hidden="true"></em> can be changed from the LCD controller.
{% endalert %}</p>
<p>{% alert info %}
Certain EEPROM behaviors may be confusing. For example, when you edit the configurations and re-flash the firmware, you may discover that your new settings don&#39;t have any effect! What&#39;s going on? They are still overridden by the settings last saved to EEPROM! Use <code>M502</code> to restore settings to defaults, then <code>M500</code> to save them. Note that <code>M503</code> shows current settings in volatile memory even without <code>EEPROM_SETTINGS</code>.
{% endalert %}</p>
<h3 id="host-keepalive">Host Keepalive</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HOST_KEEPALIVE_FEATURE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_KEEPALIVE_INTERVAL 2</span>
</code></pre>
<p>When Host Keepalive is enabled Marlin will send a busy status message to the host every couple of seconds when it can&#39;t accept commands. Disable if your host doesn&#39;t like keepalive messages. Use <code>DEFAULT_KEEPALIVE_INTERVAL</code> for the default number of seconds between &quot;busy&quot; messages. Override with <a href="/docs/gcode/M113.html"><code>M113</code></a>.</p>
<h3 id="free-memory-watcher">Free Memory Watcher</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define M100_FREE_MEMORY_WATCHER</span>
</code></pre>
<p>Uncomment to add the <code>M100</code> Free Memory Watcher for debugging purposes.</p>
<h3 id="inch-units">Inch Units</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define INCH_MODE_SUPPORT</span>
</code></pre>
<p>This option adds support for the <code>G20</code> and <code>G21</code> commands, allowing G-Code to specify units in inches.</p>
<h3 id="temperature-units">Temperature Units</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define TEMPERATURE_UNITS_SUPPORT</span>
</code></pre>
<p>This option adds support for <code>M149 C</code>, <code>M149 K</code>, and <code>M149 F</code> to set temperature units to Celsius, Kelvin, or Fahrenheit. Without this option all temperatures must be specified in Celsius units.</p>
<h3 id="lcd-material-presets-em-class-fa-fa-sticky-note-o-text-info-aria-hidden-true-em-em-class-fa-fa-desktop-text-info-aria-hidden-true-em-">LCD Material Presets <em class="fa fa-sticky-note-o text-info" aria-hidden="true"></em> <em class="fa fa-desktop text-info" aria-hidden="true"></em></h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREHEAT_1_TEMP_HOTEND 180</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREHEAT_1_TEMP_BED     70</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREHEAT_1_FAN_SPEED     0 <span class="hljs-comment">// Value from 0 to 255</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREHEAT_2_TEMP_HOTEND 240</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREHEAT_2_TEMP_BED    110</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREHEAT_2_FAN_SPEED     0 <span class="hljs-comment">// Value from 0 to 255</span></span>
</code></pre>
<p>These are the default values for the <code>Prepare</code> &gt; <code>Preheat</code> LCD menu options. These values can be overridden using the <code>M145</code> command or the <code>Control</code> &gt; <code>Temperature</code> &gt; <code>Preheat Material X conf</code> submenus.</p>
<h3 id="nozzle-park">Nozzle Park</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">//#define NOZZLE_PARK_FEATURE</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ENABLED(NOZZLE_PARK_FEATURE)</span>
  <span class="hljs-comment">// Specify a park position as { X, Y, Z }</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>Park the nozzle at the given XYZ position on idle or <code>G27</code>.</p>
<p>The &quot;P&quot; parameter controls the action applied to the Z axis:</p>
<ul>
<li><code>P0</code> - (Default) If Z is below park Z raise the nozzle.</li>
<li><code>P1</code> - Raise the nozzle always to Z-park height.</li>
<li><code>P2</code> - Raise the nozzle by Z-park amount, limited to <code>Z_MAX_POS</code>.</li>
</ul>
<h3 id="nozzle-clean">Nozzle Clean</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define NOZZLE_CLEAN_FEATURE</span>
</code></pre>
<p>Adds the <code>G12</code> command to perform a nozzle cleaning process. See <code>Configuration.h</code> for additional configuration options.</p>
<h3 id="print-job-timer">Print Job Timer</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINTJOB_TIMER_AUTOSTART</span>
</code></pre>
<p>Automatically start and stop the print job timer when <code>M104</code>/<code>M109</code>/<code>M190</code> commands are received. Also adds the following commands to control the timer:</p>
<ul>
<li><code>M75</code> - Start the print job timer.</li>
<li><code>M76</code> - Pause the print job timer.</li>
<li><code>M77</code> - Stop the print job timer.</li>
</ul>
<h3 id="print-counter">Print Counter</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define PRINTCOUNTER</span>
</code></pre>
<p>When enabled Marlin will keep track of some print statistics such as:</p>
<ul>
<li>Total print jobs</li>
<li>Total successful print jobs</li>
<li>Total failed print jobs</li>
<li>Total time printing</li>
</ul>
<p>This information can be viewed by the <code>M78</code> command.</p>
<h2 id="lcd-language">LCD Language</h2>
<h3 id="user-interface-language">User Interface Language</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LCD_LANGUAGE en</span>
</code></pre>
<p>Choose your preferred language for the LCD controller here. Supported languages include:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Language</th>
<th></th>
<th>Code</th>
<th>Language</th>
<th></th>
<th>Code</th>
<th>Language</th>
</tr>
</thead>
<tbody>
<tr>
<td>en</td>
<td>English (Default)</td>
<td></td>
<td>an</td>
<td>Aragonese</td>
<td></td>
<td>bg</td>
<td>Bulgarian</td>
</tr>
<tr>
<td>ca</td>
<td>Catalan</td>
<td></td>
<td>cn</td>
<td>Chinese</td>
<td></td>
<td>cz</td>
<td>Czech</td>
</tr>
<tr>
<td>de</td>
<td>German</td>
<td></td>
<td>el</td>
<td>Greek</td>
<td></td>
<td>el-gr</td>
<td>Greek (Greece)</td>
</tr>
<tr>
<td>es</td>
<td>Spanish</td>
<td></td>
<td>eu</td>
<td>Basque-Euskera</td>
<td></td>
<td>fi</td>
<td>Finnish</td>
</tr>
<tr>
<td>fr</td>
<td>French</td>
<td></td>
<td>gl</td>
<td>Galician</td>
<td></td>
<td>hr</td>
<td>Croatian</td>
</tr>
<tr>
<td>it</td>
<td>Italian</td>
<td></td>
<td>kana</td>
<td>Japanese</td>
<td></td>
<td>kana_utf8</td>
<td>Japanese (UTF8)</td>
</tr>
<tr>
<td>nl</td>
<td>Dutch</td>
<td></td>
<td>pl</td>
<td>Polish</td>
<td></td>
<td>pt</td>
<td>Portuguese</td>
</tr>
<tr>
<td>pt-br</td>
<td>Portuguese (Brazilian)</td>
<td></td>
<td>pt-</td>
<td>Portuguese (Brazilian UTF8)</td>
<td></td>
<td>pt_utf8</td>
<td>Portuguese (UTF8)</td>
</tr>
<tr>
<td>ru</td>
<td>Russian</td>
<td></td>
<td>tr</td>
<td>Turkish</td>
<td></td>
<td>uk</td>
<td>Ukrainian</td>
</tr>
</tbody>
</table>
<p>See <code>language.h</code> for the latest list of supported languages and their international language codes.</p>
<h3 id="hd44780-character-set">HD44780 Character Set</h3>
<p><img src="//marlinfw.org/assets/images/config/lcd-charset.png" alt="LCD Charset">{: .floater.framed}</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DISPLAY_CHARSET_HD44780 JAPANESE</span>
</code></pre>
<p>This option applies only to character-based displays. Character-based displays (based on the Hitachi HD44780) provide an ASCII character set plus one of the following language extensions:</p>
<ul>
<li><code>JAPANESE</code> ... the most common</li>
<li><code>WESTERN</code> .... with more accented characters</li>
<li><code>CYRILLIC</code> ... for the Russian language</li>
</ul>
<p>To determine the language extension installed on your controller:</p>
<ul>
<li>Compile and upload with <code>LCD_LANGUAGE</code> set to &#39;test&#39;</li>
<li>Click the controller to view the LCD menu</li>
<li>The LCD will display Japanese, Western, or Cyrillic text</li>
</ul>
<p>For in-depth info on the Marlin display system, see <a href="https://github.com/MarlinFirmware/Marlin/wiki/LCD-Language">LCD Language Font System</a> on the Marlin wiki.</p>
<p><img src="//marlinfw.org/assets/images/config/sdcard.jpg" alt="SD Card">{: .floater}</p>
<h2 id="lcd-type">LCD Type</h2>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define ULTRA_LCD // Character based</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define DOGLCD    // Full graphics display</span>
</code></pre>
<p>The base LCD Type is either character-based or graphical. Marlin will automatically set the correct one for your specific display, specified below. Unless your display is unsupported by Marlin, you can leave these options disabled.</p>
<h2 id="sd-card">SD Card</h2>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define SDSUPPORT // Enable SD Card Support in Hardware Console</span>
</code></pre>
<p>Enable to use SD printing, whether as part of an LCD controller or as a standalone SDCard slot.</p>
<p>{% alert info %}
The <code>SDSUPPORT</code> option must be enabled or SD printing will not be supported. It is no longer enabled automatically for LCD controllers with built-in SDCard slot.
{% endalert %}</p>
<h3 id="spi-speed">SPI Speed</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define SPI_SPEED SPI_HALF_SPEED</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define SPI_SPEED SPI_QUARTER_SPEED</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define SPI_SPEED SPI_EIGHTH_SPEED</span>
</code></pre>
<p>Uncomment ONE of these options to use a slower SPI transfer speed. This is usually required if you&#39;re getting volume init errors.</p>
<h3 id="enable-crc">Enable CRC</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define SD_CHECK_AND_RETRY</span>
</code></pre>
<p>Use CRC checks and retries on the SD communication.</p>
<p><img src="//marlinfw.org/assets/images/config/encoder.jpg" alt="Encoder Knob">{: .floater}</p>
<h2 id="encoder">Encoder</h2>
<h3 id="encoder-resolution">Encoder Resolution</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define ENCODER_PULSES_PER_STEP 1</span>
</code></pre>
<p>This option overrides the default number of encoder pulses needed to produce one step. Should be increased for high-resolution encoders.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define ENCODER_STEPS_PER_MENU_ITEM 5</span>
</code></pre>
<p>Use this option to override the number of step signals required to move between next/prev menu items.</p>
<h3 id="encoder-direction">Encoder Direction</h3>
<p>Test your encoder&#39;s behavior first with both of the following options disabled.</p>
<ul>
<li>Reversed Value Edit and Menu Nav? Enable <code>REVERSE_ENCODER_DIRECTION</code>.</li>
<li>Reversed Menu Navigation only? Enable <code>REVERSE_MENU_DIRECTION</code>.</li>
<li>Reversed Value Editing only? Enable <em>BOTH</em> options.</li>
</ul>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define REVERSE_ENCODER_DIRECTION</span>
</code></pre>
<p>This option reverses the encoder direction everywhere. Set if CLOCKWISE causes values to DECREASE.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define REVERSE_MENU_DIRECTION</span>
</code></pre>
<p>This option reverses the encoder direction for navigating LCD menus. If CLOCKWISE normally moves DOWN this makes it go UP. If CLOCKWISE normally moves UP this makes it go DOWN.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define INDIVIDUAL_AXIS_HOMING_MENU</span>
</code></pre>
<p>Add individual axis homing items (Home X, Home Y, and Home Z) to the LCD menu.</p>
<p><img src="//marlinfw.org/assets/images/config/piezo.png" alt="Piezo">{: .floater}</p>
<h2 id="speaker">Speaker</h2>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define SPEAKER</span>
</code></pre>
<p>By default Marlin assumes you have a buzzer with a fixed frequency. If you have a speaker that can produce tones, enable it here.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100</span>
<span class="hljs-regexp">//</span><span class="hljs-comment">#define LCD_FEEDBACK_FREQUENCY_HZ 1000</span>
</code></pre>
<p>The duration and frequency for the UI feedback sound. Set these to 0 to disable audio feedback in the LCD menus. Test audio output with the G-Code <code>M300 S&lt;frequency Hz&gt; P&lt;duration ms&gt;</code></p>
<h2 id="lcd-controller">LCD Controller</h2>
<p><img src="//marlinfw.org/assets/images/config/controllers.png" alt="LCD Controllers">{: .floater}</p>
<p>Marlin includes support for several controllers. The two most popular controllers supported by Marlin are:</p>
<ul>
<li><code>REPRAP_DISCOUNT_SMART_CONTROLLER</code> A 20 x 4 character-based LCD controller with click-wheel.</li>
<li><code>REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER</code> A monochrome 128 x 64 pixel-based LCD controller with click-wheel. Able to display simple bitmap graphics and up to 5 lines of text.</li>
</ul>
<p>Most other LCD controllers are variants of these. Enable just one of the following options for your specific controller:</p>
<h3 id="character-lcds">Character LCDs</h3>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ULTIMAKERCONTROLLER</code></td>
<td>The original Ultimaker Controller.</td>
</tr>
<tr>
<td><code>ULTIPANEL</code></td>
<td><a href="http://www.thingiverse.com/thing:15081">ULTIPANEL</a> as seen on Thingiverse.</td>
</tr>
<tr>
<td><code>PANEL_ONE</code></td>
<td><a href="http://reprap.org/wiki/PanelOne">PanelOne from T3P3</a> (via RAMPS 1.4 AUX2/AUX3). A variant of <code>ULTIMAKERCONTROLLER</code>.</td>
</tr>
<tr>
<td><code>REPRAP_DISCOUNT_SMART_CONTROLLER</code></td>
<td><a href="http://reprap.org/wiki/RepRapDiscount_Smart_Controller">RepRapDiscount Smart Controller</a>. Usually sold with a white PCB.</td>
</tr>
<tr>
<td><code>G3D_PANEL</code></td>
<td><a href="http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel">Gadgets3D G3D LCD/SD Controller</a>. Usually sold with a blue PCB.</td>
</tr>
<tr>
<td><code>RIGIDBOT_PANEL</code></td>
<td><a href="http://www.inventapart.com/">RigidBot Panel V1.0</a>.</td>
</tr>
</tbody>
</table>
<h3 id="graphical-lcds">Graphical LCDs</h3>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CARTESIO_UI</code></td>
<td><a href="http://mauk.cc/webshop/cartesio-shop/electronics/user-interface">Cartesio UI</a>.</td>
</tr>
<tr>
<td><code>MAKRPANEL</code></td>
<td><a href="http://reprap.org/wiki/MaKr3d_MaKrPanel">MaKr3d Makr-Panel</a> with graphic controller and SD support.</td>
</tr>
<tr>
<td><code>REPRAPWORLD_GRAPHICAL_LCD</code></td>
<td><a href="https://reprapworld.com/?products_details&amp;products_id/1218">ReprapWorld Graphical LCD</a>.</td>
</tr>
<tr>
<td><code>VIKI2</code></td>
<td><a href="http://panucatt.com">Panucatt Devices</a> <a href="http://panucatt.com">Viki 2.0</a>.</td>
</tr>
<tr>
<td><code>miniVIKI</code></td>
<td><a href="http://panucatt.com">mini Viki with Graphic LCD</a>.</td>
</tr>
<tr>
<td><code>ELB_FULL_GRAPHIC_CONTROLLER</code></td>
<td><a href="https://github.com/eboston/Adafruit-ST7565-Full-Graphic-Controller/">Adafruit ST7565 Full Graphic Controller</a>.</td>
</tr>
<tr>
<td><code>REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER</code></td>
<td><a href="http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller">RepRapDiscount Full Graphic Smart Controller</a>.</td>
</tr>
<tr>
<td><code>MINIPANEL</code></td>
<td><a href="http://reprap.org/wiki/Mini_panel">MakerLab Mini Panel</a> with graphic controller and SD support.</td>
</tr>
<tr>
<td><code>BQ_LCD_SMART_CONTROLLER</code></td>
<td>BQ LCD Smart Controller shipped with the BQ Hephestos 2 and Witbox 2.</td>
</tr>
</tbody>
</table>
<h3 id="keypads">Keypads</h3>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REPRAPWORLD_KEYPAD</code></td>
<td><a href="http://reprapworld.com/?products_details&amp;products_id=202&amp;cPath=1591_1626">RepRapWorld Keypad v1.1</a> Use <code>REPRAPWORLD_KEYPAD_MOVE_STEP</code> to set how much the robot should move on each keypress (e.g., 10mm per click).</td>
</tr>
</tbody>
</table>
<h3 id="i2c-character-lcds">I2C Character LCDs</h3>
<p>These controllers all require the <a href="https://github.com/kiyoshigawa/LiquidCrystal_I2C">LiquidCrystal_I2C library</a>.</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RA_CONTROL_PANEL</code></td>
<td>Elefu RA Board Control Panel</td>
</tr>
<tr>
<td><code>LCD_I2C_SAINSMART_YWROBOT</code></td>
<td>Sainsmart <a href="http://henrysbench.capnfatz.com/henrys-bench/arduino-displays/ywrobot-lcm1602-iic-v1-lcd-arduino-tutorial/">YWRobot LCM1602 LCD Display</a>.</td>
</tr>
<tr>
<td><code>LCM1602</code></td>
<td>Generic LCM1602 LCD adapter</td>
</tr>
<tr>
<td><code>LCD_I2C_PANELOLU2</code></td>
<td>PANELOLU2 LCD with status LEDs, separate encoder and click inputs. The click input can either be directly connected to a pin (if <code>BTN_ENC</code> is defined) or read through I2C (with <code>BTN_ENC</code> undefined). Requires <a href="https://github.com/lincomatic/LiquidTWI2">LiquidTWI2 library</a> v1.2.3 or later.</td>
</tr>
<tr>
<td><code>LCD_I2C_VIKI</code></td>
<td>Panucatt VIKI LCD with status LEDs, integrated click &amp; L/R/U/D buttons, separate encoder inputs.</td>
</tr>
<tr>
<td><code>SAV_3DLCD</code></td>
<td>Shift register panels. <a href="https://goo.gl/aJJ4sH">2 wire Non-latching LCD SR</a>. See <a href="http://reprap.org/wiki/SAV_3D_LCD">LCD configuration</a>.</td>
</tr>
</tbody>
</table>
<h3 id="i2c-graphical-lcds">I2C Graphical LCDs</h3>
<p>These controllers all require the <a href="https://github.com/kiyoshigawa/LiquidCrystal_I2C">LiquidCrystal_I2C library</a>.</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>U8GLIB_SSD1306</code></td>
<td>SSD1306 OLED full graphics generic display.</td>
</tr>
<tr>
<td><code>SAV_3DGLCD</code></td>
<td>SAV OLED LCD module support using either SSD1306 or SH1106 based LCD modules.</td>
</tr>
</tbody>
</table>
<h2 id="extras-2">Extras 2</h2>
<h3 id="fan-pwm">Fan PWM</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define FAST_PWM_FAN</span>
</code></pre>
<p>Increase the FAN PWM frequency. Removes the PWM noise but increases heating in the FET/Arduino.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define FAN_SOFT_PWM</span>
</code></pre>
<p>Use software PWM to drive the fan, as with the heaters. This uses a very low frequency which is not as annoying as with the hardware PWM. On the other hand, if this frequency is too low, you should also increment <code>SOFT_PWM_SCALE</code>.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SOFT_PWM_SCALE 0</span>
</code></pre>
<p>Incrementing this by 1 will double the software PWM frequency, affecting heaters (and the fan if <code>FAN_SOFT_PWM</code> is enabled). However, control resolution will be halved for each increment; at zero value, there are 128 effective control positions.</p>
<h3 id="temperature-status-leds">Temperature Status LEDs</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define TEMP_STAT_LEDS</span>
</code></pre>
<p>Temperature status LEDs that display the hotend and bed temperature. If all hotend and bed temperature setpoint are &lt; 54C then the BLUE led is on. Otherwise the RED led is on. There is 1C hysteresis.</p>
<h3 id="photo-pin">Photo Pin</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define PHOTOGRAPH_PIN     23</span>
</code></pre>
<p><code>M240</code> triggers a camera by emulating a Canon RC-1 Remote Data as described on <a href="http://www.doc-diy.net/photo/rc-1_hacked/">this site</a>.</p>
<h3 id="skeinforge-arc-fix">SkeinForge Arc Fix</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define SF_ARC_FIX</span>
</code></pre>
<p>Files sliced with SkeinForge contain the wrong arc GCodes when using &quot;Arc Point&quot; as fillet procedure. This option works around that bug, but otherwise should be left off.</p>
<h2 id="extras-3">Extras 3</h2>
<h3 id="paste-extruder">Paste Extruder</h3>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span> Support <span class="hljs-keyword">for</span> the BariCUDA Paste Extruder.
<span class="hljs-regexp">//</span><span class="hljs-comment">#define BARICUDA</span>
</code></pre>
<p>Marlin includes support for the <a href="http://www.thingiverse.com/thing:26343">Baricuda Extruder for 3D Printing Sugar and Chocolate</a> also <a href="http://www.github.com/jmil/BariCUDA">hosted on GitHub</a>. The feature adds the codes <code>M126</code>, <code>M127</code>, <code>M128</code>, and <code>M129</code> for controlling the pump and valve of the Baricuda.</p>
<p><a href="http://www.instructables.com/id/3D-Printer-RGB-LED-Feedback/"><img src="//marlinfw.org/assets/images/config/led-lights.jpg" alt="LED Lights">{: .floater.framed}</a>{:target=&quot;_blank&quot;}</p>
<h3 id="indicator-leds">Indicator LEDs</h3>
<p>Marlin currently supplies two options for RGB-addressable color indicators. In both cases the color is set using <code>M150 Rr Ug Bb</code> to specify RGB components from 0 to 255.</p>
<pre><code class="lang-cpp hljs">//<span class="hljs-keyword">define</span> <span class="hljs-section">BlinkM</span>/CyzRgb Support
//<span class="hljs-comment">#define BLINKM</span>
</code></pre>
<p>The BLINKM board supplies the backlighting for some LCD controllers. Its color is set using I2C messages.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-comment">// Support for an RGB LED using 3 separate pins with optional PWM</span>
<span class="hljs-comment">//#define RGB_LED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ENABLED(RGB_LED)</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RGB_LED_R_PIN 34</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RGB_LED_G_PIN 43</span>
  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RGB_LED_B_PIN 35</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre>
<p>An inexpensive RGB LED can be used simply by assigning digital pins for each component. If the pins are able to do hardware PWM then a wide range of colors will be available. With simple digital pins only 7 colors are possible.</p>
<h3 id="servos">Servos</h3>
<p><img src="//marlinfw.org/assets/images/config/servo.png" alt="Servo">{: .floater}</p>
<h4 id="number-of-servos">Number of Servos</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#</span><span class="bash">define NUM_SERVOS 1 // Servo index starts with 0 <span class="hljs-keyword">for</span> M280 <span class="hljs-built_in">command</span></span>
</code></pre>
<p>The total number of servos to enable for use. One common application for a servo is a Z bed probe consisting of an endstop switch mounted on a rotating arm. To use one of the servo connectors for this type of probe, set <code>Z_ENDSTOP_SERVO_NR</code> in the probe options above.</p>
<h4 id="servo-deactivation">Servo Deactivation</h4>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SERVO_DELAY 300</span>
</code></pre>
<p>Delay (in microseconds) before the next move will start, to give the servo time to reach its target angle. 300ms is a good value but you can try less delay. Specify a large enough delay so the servo has enough time to complete a full motion before deactivation.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define DEACTIVATE_SERVOS_AFTER_MOVE</span>
</code></pre>
<p>With this option servos are powered only during movement, then turned off to prevent jitter. We recommend enabling this option to keep electrical noise from active servos from interfering with other components. The high amperage generated by extruder motor wiring during movement can also induce movement in active servos. Leave this option enabled to avoid all such servo-related troubles.</p>
<h3 id="filament-width-sensor">Filament Width Sensor</h3>
<iframe style="float:right;margin:0 0 1em 1em;" title="YouTube video player" width="240" height="195" src="http://www.youtube.com/embed/W93dFxF425s?autoplay=0" frameborder="0" allowfullscreen></iframe>

<pre><code class="lang-cpp hljs"><span class="hljs-regexp">//</span><span class="hljs-comment">#define FILAMENT_WIDTH_SENSOR</span>
</code></pre>
<p>Enable to add support for a filament width sensor such as <a href="http://www.thingiverse.com/thing:454584">Filament Width Sensor Prototype Version 3</a>. With a filament sensor installed, Marlin can adjust the flow rate according to the measured filament width. Adjust the sub-options below according to your setup.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_NOMINAL_FILAMENT_DIA 3.00</span>
</code></pre>
<p>The &quot;nominal&quot; filament diameter as written on the filament spool. If you typically use 1.75mm filament, but physically measure the diameter as 1.70mm, you should still use 1.75. Marlin will compensate automatically. The same goes for 3.00mm filament that measures closer to 2.85mm.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILAMENT_SENSOR_EXTRUDER_NUM 0</span>
</code></pre>
<p>Only one extruder can have a filament sensor. Specify here which extruder has it.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MEASUREMENT_DELAY_CM        14</span>
</code></pre>
<p>Distance from the filament width sensor to the middle of the filament path (i.e., the nozzle opening).</p>
<pre><code class="lang-cpp hljs">#<span class="hljs-built_in">define</span> MEASURED_UPPER_LIMIT         <span class="hljs-number">3.30</span>  //upper <span class="hljs-built_in">limit</span> <span class="hljs-built_in">factor</span> used <span class="hljs-keyword">for</span> sensor reading validation <span class="hljs-keyword">in</span> mm
#<span class="hljs-built_in">define</span> MEASURED_LOWER_LIMIT         <span class="hljs-number">1.90</span>  //lower <span class="hljs-built_in">limit</span> <span class="hljs-built_in">factor</span> <span class="hljs-keyword">for</span> sensor reading validation <span class="hljs-keyword">in</span> mm
</code></pre>
<p>The range of your filament width. Set these according to your filament preferences. The sample values here apply to 3mm. For 1.75mm you&#39;ll use a range more like 1.60 to 1.90.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_MEASUREMENT_DELAY       20</span>
</code></pre>
<p>This defines the size of the buffer to allocate for use with <code>MEASUREMENT_DELAY_CM</code>. The value must be greater than or equal to <code>MEASUREMENT_DELAY_CM</code>. Keep this setting low to reduce RAM usage.</p>
<pre><code class="lang-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILAMENT_LCD_DISPLAY</span>
</code></pre>
<p>Periodically display a message on the LCD showing the measured filament diameter.</p>
